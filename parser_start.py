import aiosqlite
# import schedule
import asyncio
import aiocron

from datetime import datetime
from aiologger import Logger
from aiologger.levels import LogLevel
from aiologger.formatters.base import Formatter

from database.db_insert import InsertIntoDB, MainDB
from database.db_select import SelectQuery
from database.db_owners_tokens import OwnersTokensDB
from database.db_mint import MintDB
from parser.parsing import Parser

# formatter = Formatter('%(asctime)s [%(levelname)s] %(filename)s -> %(funcName)s line:%(lineno)d %(message)s')
formatter = Formatter('%(asctime)s [%(levelname)s] %(message)s')
logger = Logger.with_default_handlers(name='my-logger', formatter=formatter, level=LogLevel.INFO)

class GetDataStargaze:
    async def main_insert(self, coll_addr: str, token_num: int):
        """–í—Å—Ç–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Ç–∞–±–ª–∏—Ü—ã collections, tokens, rarity"""
        if coll_addr:
            coll_data = await Parser().get_collection_data(coll_addr)  # –ø–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ —á–µ—Ä–µ–∑ api
            # ==> coll_name, floor_price, tokens_count, creator_addr
            if not isinstance(coll_data, int):  # –µ—Å–ª–∏ —Ç–∞–º –Ω–µ —Å—Ç–∞—Ç—É—Å –∫–æ–¥ —Å –æ—à–∏–±–∫–æ–π
                coll_name, floor_price, tokens_count, creator_addr = \
                    coll_data[0], coll_data[1], coll_data[2], coll_data[3]
                floor_price = floor_price if floor_price else None
                insert_coll_data = [coll_name, coll_addr, tokens_count]
                try:  # –Ω–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É collections
                    await logger.info(f"Try insert collection {coll_name}")
                    await InsertIntoDB().insert_collections(insert_data=insert_coll_data)
                    await logger.info(f'[+] Insert new collection {coll_name}')
                except aiosqlite.IntegrityError as warn:
                    await logger.warning(warn)
                coll_id = await SelectQuery().select_coll_id(coll_addr)
                # coll_id = coll_id[0] if coll_id else None
                token_data = await Parser().get_tokens_data(coll_addr, token_num)  # –ø–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω–∞
                if not isinstance(token_data, int):  # –µ—Å–ª–∏ —Ç–∞–º –Ω–µ —Å—Ç–∞—Ç—É—Å –∫–æ–¥ —Å –æ—à–∏–±–∫–æ–π
                    token_name, rarity = token_data[0], token_data[1]
                    insert_token_data = [coll_id, token_name, int(token_num)]
                    try:  # –Ω–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É tokens
                        await logger.info(f"Try insert token {token_name}")
                        await InsertIntoDB().insert_tokens(insert_token_data)
                        await logger.info(f"[+] Insert new token {token_name} from {coll_name}")
                    except aiosqlite.IntegrityError as warn:
                        await logger.warning(warn)
                    token_id = await SelectQuery().select_token_id(coll_id, int(token_num))
                    # token_id = token_id[0] if token_id else None
                    rarity_max = await SelectQuery().select_rarity_max(token_id)  # –ø–æ–ª—É—á–∞–µ–º —Å–∞–º—É—é –±–æ–ª—å—à—É—é —Ä–µ–¥–∫–æ—Å—Ç—å
                    # rarity_max = rarity_max[0] if rarity_max else None
                    try:
                        # –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É rarity
                        await logger.info(f"Try insert rarity {token_name} Rarity #{rarity}/{rarity_max}")
                        await InsertIntoDB().insert_rarity([token_id, rarity, rarity_max])
                        await logger.info(f"[+] Insert new rarity: {token_name} Rarity #{rarity}/{rarity_max}")
                    except aiosqlite.IntegrityError as warn:
                        await logger.warning(warn)
                    return coll_id, coll_name, token_id, floor_price
        else:
            return None, None, None, None

    async def owners_inser(self, owner_addr: str):
        """–í—Å—Ç–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤–ª–∞–¥–µ–ª—å—Ü–µ–≤"""
        if owner_addr:
            owner_name = await Parser().get_owner_name(owner_addr)
            insert_owner_data = [owner_addr, owner_name]
            try:
                # –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É owners
                await InsertIntoDB().insert_owners(insert_owner_data)
                await logger.info(f"Insert new owner üë§ {owner_addr} / {owner_name}")
            except aiosqlite.IntegrityError:
                pass

    async def sales_parsing(self):
        """–ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ –ø—Ä–æ–¥–∞–∂–∞–º.
        –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—ã collections, tokens, rarity, floors, owners, sales –Ω–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏"""
        await logger.info(" ############ Get Sales data.. ############ ")
        data_sales = Parser().get_sales_data()
        async for data in data_sales:
            if data:  # –ï—Å–ª–∏ –≤–¥—Ä—É–≥ –≤–µ—Ä–Ω–µ—Ç—Å—è None
                block_height, coll_addr, token_num, price_stars, price_usd, seller_addr, buyer_addr, date_create = \
                    data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]
                coll_id, coll_name, token_id, floor_price = await self.main_insert(coll_addr, token_num)
                if coll_id:
                    await self.owners_inser(seller_addr)
                    await self.owners_inser(buyer_addr)
                    seller_id = await SelectQuery().select_owner_id(seller_addr)
                    # seller_id = seller_id[0] if seller_id else None
                    buyer_id = await SelectQuery().select_owner_id(buyer_addr)
                    # buyer_id = buyer_id[0] if buyer_id else None
                    insert_sales_data = [block_height, coll_id, token_id, seller_id, buyer_id,
                                         price_stars, price_usd, date_create]
                    try:
                        # –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É sales
                        await InsertIntoDB().insert_sales(insert_sales_data)
                        await logger.info(f"Insert new sale üíµ | {block_height} | {coll_name} "
                                     f"{token_num} {price_stars} STARS create at {date_create}")
                    except aiosqlite.IntegrityError as warn:
                        await logger.warning(warn)
                    try:
                        # –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É floors
                        await InsertIntoDB().insert_floors([coll_id, floor_price])
                        await logger.info(f"Insert floor price {floor_price} STARS {coll_name}")
                    except aiosqlite.IntegrityError as warn:
                        await logger.warning(warn)
                    except aiosqlite.OperationalError as err:
                        await logger.error(err)

    async def burns_parsing(self):
        """–ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ —Å–∂–∏–≥–∞–Ω–∏—è–º —Ç–æ–∫–µ–Ω–æ–≤.
        –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—ã collections, tokens, rarity, owners, burns –Ω–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏"""
        await logger.info(" ############ Get Burns data.. ############ ")
        data_burns = Parser().get_burn_data()
        # block_height, coll_addr, token_num, sender_addr, date_create
        async for data in data_burns:
            if data:
                block_height, coll_addr, token_num, sender_addr, date_create = \
                    data[0], data[1], data[2], data[3], data[4]
                coll_id, coll_name, token_id, floor_price = await self.main_insert(coll_addr, token_num)
                if coll_id:
                    await self.owners_inser(sender_addr)
                    sender_id = await SelectQuery().select_owner_id(sender_addr)
                    # sender_id = sender_id[0] if sender_id else None
                    insert_burns_data = [block_height, coll_id, token_id, sender_id, date_create]
                    try:
                        await InsertIntoDB().insert_burns(insert_burns_data)
                        await logger.info(f"Insert new burn üî• | {block_height} | {coll_name} {token_num} "
                                     f"create at {date_create}")
                    except aiosqlite.IntegrityError as warn:
                        await logger.warning(warn)
                    except aiosqlite.OperationalError as err:
                        await logger.error(err)

    async def mints_parsing(self):
        """–ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ –º–∏–Ω—Ç–∞–º.
        –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—ã collections, tokens, rarity, owners, mints –Ω–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏"""
        await logger.info(" ############ Get Mints data.. ############ ")
        # data_mints = Parser().get_mints_data()
        async for data in MintDB().select_mints_data():
            if data:
                block_height, coll_addr, token_num, recipient_addr, creator_addr, \
                    price_stars, price_usd, date_create = data[0], data[1], data[2], \
                    data[3], data[4], data[5], data[6], data[7]
                coll_id, coll_name, token_id, floor_price = await self.main_insert(coll_addr, token_num)
                await self.owners_inser(recipient_addr)
                await self.owners_inser(creator_addr)
                recipient_id = await SelectQuery().select_owner_id(recipient_addr)
                # recipient_id = recipient_id[0] if recipient_id else None
                creator_id = await SelectQuery().select_owner_id(creator_addr)
                # creator_id = creator_id[0] if creator_id else None
                insert_mints_data = [block_height, coll_id, token_id, recipient_id,
                                     creator_id, price_stars, price_usd, date_create]
                try:
                    await InsertIntoDB().insert_mints(insert_mints_data)
                    await logger.info(f"Insert new mint üçÉ | {block_height} | {coll_name} {token_num}  "
                                      f"{price_stars} STARS create at {date_create}")
                except aiosqlite.IntegrityError as warn:
                    await logger.warning(warn)
                except aiosqlite.OperationalError as err:
                    await logger.error(err)

    async def listings_parsing(self):
        """–ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ –Ω–æ–≤—ã–º —Ä–∞–∑–º–µ—â–µ–Ω–∏—è–º.
        –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—ã collections, tokens, rarity, owners, mints –Ω–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏"""
        await logger.info(" ############ Get Listing data.. ############ ")
        data_listing = Parser().get_listing_and_update_price_data()
        async for data in data_listing:
            if data:
                block_height, coll_addr, token_num, seller_addr, price_stars, price_usd, \
                    event_name, date_create = data[0], data[1], data[2], \
                    data[3], data[4], data[5], data[6], data[7]
                coll_id, coll_name, token_id, floor_price = await self.main_insert(coll_addr, token_num)
                if seller_addr:
                    await self.owners_inser(seller_addr)
                    seller_id = await SelectQuery().select_owner_id(seller_addr)
                    # seller_id = seller_id[0] if seller_id else None
                else:
                    seller_id = None
                insert_mints_data = [block_height, coll_id, token_id, seller_id,
                                     price_stars, price_usd, event_name, date_create]
                try:
                    await InsertIntoDB().insert_listings(insert_mints_data)
                    await logger.info(f"Insert new listing üìà | {block_height} | {coll_name} {token_num} "
                                      f"{price_stars} STARS create at {date_create}")
                except aiosqlite.IntegrityError as warn:
                    await logger.warning(warn)
                except aiosqlite.OperationalError as err:
                    await logger.error(err)

    async def check_owners_tokens(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∫–∏–µ —Ç–æ–∫–µ–Ω—ã –µ—Å—Ç—å –Ω–∞ –∫–æ—à–µ–ª—å–∫–µ –≤—Å–µ –∞–¥—Ä–µ—Å–∞"""
        # insert_data = [owner_id, coll_id, token_id, for_sale, date_create]
        count_owner = await SelectQuery().select_count_owners()
        count = count_owner
        async for owner_addr in SelectQuery().select_owner_addr():  # –≤—ã—Ç–∞—Å–∫–∏–≤–∞–µ–º –ø–æ –æ—á–µ—Ä–µ–¥–∏ –∞–¥—Ä–µ—Å–∞ –≤—Å–µ—Ö –∫–æ—à–µ–ª—å–∫–æ–≤
            async for data in Parser().owners_parsing(owner_addr):  # –ø–æ–ª—É—á–∞–µ–º –µ–æ –¥–∞–Ω–Ω—ã–µ
                await logger.info(f"Addr {count}/{count_owner}. Get data {data}")
                coll_addr, token_name, token_num, for_sale, date_create = \
                    data[0], data[1], data[2], data[3], data[4]
                if await SelectQuery().select_owner_id(owner_addr):  # —Ç–∞–∫–æ–π –≤–ª–∞–¥–µ–ª–µ—Ü —É–∂–µ –µ—Å—Ç—å –≤ –ë–î
                    owner_id = await SelectQuery().select_owner_id(owner_addr)
                else:
                    await self.owners_inser(owner_addr)
                    owner_id = await SelectQuery().select_owner_id(owner_addr)
                if await SelectQuery().select_coll_id(coll_addr):  # –µ—Å–ª–∏ —Ç–∞–∫–∞—è –∫–æ–ª–ª–µ–∫—Ü–∏—è —É–∂–µ –µ—Å—Ç—å –≤ –ë–î
                    coll_id = await SelectQuery().select_coll_id(coll_addr)
                    if await SelectQuery().select_token_id(coll_id, int(token_num)):  # –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω –µ—Å—Ç—å –≤ –ë–î
                        token_id = await SelectQuery().select_token_id(coll_id, int(token_num))
                    else:  # –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω–∞ –Ω–µ—Ç —Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –∏ –ø–æ–ª—É—á–∞–µ–º –µ–≥–æ id
                        try:
                            insert_token_data = [coll_id, token_name, token_num]
                            await InsertIntoDB().insert_tokens(insert_token_data)
                            await logger.info(f"Addr {count}/{count_owner}. [+] Insert new token {token_name} from Coll_ID {coll_id}")
                        except aiosqlite.IntegrityError:
                            await logger.info(f"Addr {count}/{count_owner}. Insert UNIQUE value.")
                        token_id = await SelectQuery().select_token_id(coll_id, int(token_num))
                else:
                    coll_id, coll_name, token_id, floor_price = await self.main_insert(coll_addr, token_num)
                insert_data = [owner_id, coll_id, token_id, for_sale, date_create]  # –ø–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏
                await logger.info(f"Addr {count}/{count_owner}. Get insert data {insert_data}")
                try:
                    await OwnersTokensDB().insert_owners_tokens_single(insert_data)
                    await logger.info(f"Addr {count}/{count_owner}. Add new token for OWNER {owner_addr[:8]}...{owner_addr[-4:]}")
                except aiosqlite.IntegrityError:
                    await logger.info(f"Addr {count}/{count_owner}. Insert UNIQUE value.")
            count -= 1

    async def insert_owners_tokens_in_main(self):
        """–í—Å—Ç–∞–≤–∫–∞ –∏–∑ –ë–î owners_tokens –≤ –æ—Å–Ω–æ–≤–Ω—É–± –ë–î –≤ —Ç–∞–±–ª–∏—Ü—É owners_tokens"""
        count_rows = await OwnersTokensDB().select_count_rows()
        count = count_rows
        async for insert_data in OwnersTokensDB().select_owners_tokens_single():
            try:
                await InsertIntoDB().insert_owners_tokens(insert_data)
                await logger.info(f"Row {count}/{count_rows} insert DATA OWNERS_TOKENS to Main DB - {insert_data}")
            except aiosqlite.IntegrityError as err:
                await logger.warning(f"Row {count}/{count_rows}. Insert UNIQUE values.")
            count -= 1


@aiocron.crontab('*/2 * * * * ')
async def main():
    start = datetime.now()
    await logger.info(f" ======> Start parsing at {start}")
    task0 = asyncio.create_task(MainDB().create_tables())
    task1 = asyncio.create_task(GetDataStargaze().sales_parsing())
    task2 = asyncio.create_task(GetDataStargaze().burns_parsing())
    # task3 = asyncio.create_task(GetDataStargaze().mints_parsing())
    task4 = asyncio.create_task(GetDataStargaze().listings_parsing())
    await task0
    await task1
    await task2
    # await task3
    await task4
    # await asyncio.gather(task0, task1, task2, task3, task4)
    await logger.info(f" ======> Done {datetime.now() - start}")
    # await asyncio.sleep(1)
    return None


@aiocron.crontab('*/5 * * * * ')
async def main_mint_insert():
    """–í—Å—Ç–∞–≤–ª—è–µ–º –≤ –æ—Å–Ω–æ–≤–Ω—É—é –ë–î –¥–∞–Ω–Ω—ã–µ —Å–æ–±—Ä–∞–Ω–Ω—ã–µ –ø–æ –º–∏–Ω—Ç—É"""
    start = datetime.now()
    await logger.info(f" ======> Start MINT DATA INSERT at {start}")
    task = asyncio.create_task(GetDataStargaze().mints_parsing())
    await task
    await logger.info(f" ======> MINT DATA INSERT Done {datetime.now() - start}")



@aiocron.crontab('0-10 18,19 * * * */3')
async def mint_fast_parsing():
    """–ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ –ø–æ –º–∏–Ω—Ç–∞–º –∫–∞–∂–¥—ã–µ 3 —Å–µ–∫—É–Ω–¥—ã
    —Å 21:00 –¥–æ 21:10 –∏ —Å 22:00 –¥–æ 22:10 - –≤ —ç—Ç–æ –≤—Ä–µ–º—è,
    –∫–∞–∫ –ø—Ä–∞–≤–∏–ª–æ –Ω–æ–≤—ã–µ –º–∏–Ω—Ç—ã.
    –í Docker –≤—Ä–µ–º—è –≤ UTC, –ø–æ—ç—Ç–æ–º—É 18 –∏ 19"""
    create_db = asyncio.create_task(MintDB().create_table())
    await create_db
    data_mints = Parser().get_mints_data()
    async for insert_data in data_mints:
        try:
            await MintDB().insert_mints_data(insert_data)
            await logger.info("Get new MINT data. Work FAST PARSER.")
        except aiosqlite.IntegrityError:
            await logger.info("NO UNIQUE MINT data for insert. Work FAST PARSER.")
            pass


@aiocron.crontab('*/1 * * * *')
async def mint_slow_parsing():
    """–ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ –ø–æ –º–∏–Ω—Ç–∞–º —Ä–∞–∑ –≤ –º–∏–Ω—É—Ç—É,
    –≤ –ª—é–±–æ–µ –≤—Ä–µ–º—è –∫—Ä–æ–º–µ 20:00-20:10 –∏ 21:00-21:10,
    –≤ —ç—Ç–æ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–∞—Ä—Å–µ—Ä –∫–∞–∂–¥—ã–µ 3 —Å–µ–∫—É–Ω–¥—ã"""
    condition_hours = datetime.now().hour != 18 and datetime.now().hour != 19
    condition_minute = datetime.now().minute > 10
    if condition_hours or condition_minute:
        create_db = asyncio.create_task(MintDB().create_table())
        await create_db
        data_mints = Parser().get_mints_data()
        async for insert_data in data_mints:
            try:
                await MintDB().insert_mints_data(insert_data)
                await logger.info("Get new MINT data. Work SLOW PARSER.")
            except aiosqlite.IntegrityError:
                await logger.info("NO UNIQUE MINT data for insert. Work SLOW PARSER.")
                pass


@aiocron.crontab('35 1 * * 6')
async def check_owners():
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –Ω–æ—á—å—é –≤ —Å—É–±–±–æ—Ç—É"""
    start1 = datetime.now()
    await logger.info(f" ======> Start CHECK OWNERS parsing at {start1}")
    task0 = asyncio.create_task(MainDB().create_tables())
    task1 = asyncio.create_task(GetDataStargaze().check_owners_tokens())
    await task0
    await task1  # —Å–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ—É –æ —Ç–æ–∫–µ–Ω–∞—Ö
    await logger.info(f" ======> CHECK OWNERS Done {datetime.now() - start1}")
    return None


@aiocron.crontab('35 1 * * 7')
async def insert_owners_tokens():
    """–í—Å—Ç–∞–≤–ª—è–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ –¥–µ—Ä–∂–∞—Ç–µ–ª–µ–π —Ç–æ–∫–µ–Ω–æ–≤ –∏–∑
    –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–æ–π –ë–î –≤ –æ—Å–Ω–æ–≤–Ω—É—é.
    –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –Ω–æ—á—å—é –≤ –≤—Å, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–≥—Ä—É–∂–∞—Ç—å –ë–î (–±—É–¥–µ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø—Ä–∏ –≤—Å—Ç–∞–≤–∫–µ)"""
    start2 = datetime.now()
    task2 = asyncio.create_task(OwnersTokensDB().create_table())
    task3 = asyncio.create_task(GetDataStargaze().insert_owners_tokens_in_main())
    await logger.info(f" ======> Start INSERT Owners Tokens in MainDB at {start2}")
    await task2
    await task3  # —Å–æ–±—Ä–∞–Ω–Ω—É—é –∏–Ω—Ñ—É –ø–µ—Ä–µ–Ω–æ—Å–∏–º –∏–∑ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–æ–π –ë–î –≤ –æ—Å–Ω–æ–≤–Ω—É—é
    await logger.info(f" ======> INSERT Owners Tokens in MainDB Done {datetime.now() - start2}")


if __name__ == "__main__":
    main.start()
    check_owners.start()
    insert_owners_tokens.start()
    mint_fast_parsing.start()
    mint_slow_parsing.start()
    main_mint_insert.start()
    asyncio.get_event_loop().run_forever()
    # asyncio.run(mint_parsing())
